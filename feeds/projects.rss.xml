<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Mike Delmonaco's Blog: Posts tagged 'projects'</title>
  <description>Mike Delmonaco's Blog: Posts tagged 'projects'</description>
  <link>https://quasarbright.github.io/blog/tags/projects.html</link>
  <lastBuildDate>Mon, 29 Apr 2024 22:57:22 UT</lastBuildDate>
  <pubDate>Mon, 29 Apr 2024 22:57:22 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Math From Scratch: Creating a Proof Checker</title>
   <link>https://quasarbright.github.io/blog/2024/04/math-from-scratch-creating-a-proof-checker.html?utm_source=projects&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-quasarbright-github-io:-blog-2024-04-math-from-scratch-creating-a-proof-checker-html</guid>
   <pubDate>Mon, 29 Apr 2024 22:57:22 UT</pubDate>
   <author>Mike Delmonaco</author>
   <description>
&lt;p&gt;Math, at its core, is a network of facts that are undoubtably known to be true. We start out with some simple assumptions called axioms and prove new facts to be true using logic and reasoning. As long as the proofs are valid, then under the founding assumptions, anything that can is proven is definitely true. But when you&amp;rsquo;re proving something in math, how do you actually know if you&amp;rsquo;re doing it right? What if you make a mistake? What if you gloss over proving something which is "obviously true" that turns out to be false? One way to be sure is to have a computer check your proof, which is what we&amp;rsquo;re going to do. But first, we&amp;rsquo;re going to have to build math from the ground up.&lt;/p&gt;&lt;a href="https://quasarbright.github.io/blog/2024/04/math-from-scratch-creating-a-proof-checker.html?utm_source=projects&amp;amp;utm_medium=RSS"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</description></item>
  <item>
   <title>Guess-Free Minesweeper</title>
   <link>https://quasarbright.github.io/blog/2024/04/guess-free-minesweeper.html?utm_source=projects&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-quasarbright-github-io:-blog-2024-04-guess-free-minesweeper-html</guid>
   <pubDate>Mon, 01 Apr 2024 20:29:50 UT</pubDate>
   <author>Mike Delmonaco</author>
   <description>
&lt;p&gt;Have you ever played Minesweeper? If you have, you&amp;rsquo;ve probably run into a situation where you&amp;rsquo;re forced to guess, hoping you&amp;rsquo;re not about to step on a mine and lose the game. What if I told you it was possible to make it so you never have to guess in a game of minesweeper?&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll explain how I made a minesweeper solver and how I used the solver to generate guess-free minefields.&lt;/p&gt;&lt;a href="https://quasarbright.github.io/blog/2024/04/guess-free-minesweeper.html?utm_source=projects&amp;amp;utm_medium=RSS"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</description></item>
  <item>
   <title>Extending Automatic Differentiation to Higher Order Derivatives</title>
   <link>https://quasarbright.github.io/blog/2023/07/extending-automatic-differentiation-to-higher-order-derivatives.html?utm_source=projects&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-quasarbright-github-io:-blog-2023-07-extending-automatic-differentiation-to-higher-order-derivatives-html</guid>
   <pubDate>Fri, 07 Jul 2023 23:15:39 UT</pubDate>
   <author>Mike Delmonaco</author>
   <description>
&lt;p&gt;This is part 2 of a series of blog posts about implementing automatic differentiation. You can read part 1 &lt;a href="/blog/2022/12/understanding-and-implementing-automatic-differentiation.html"&gt;here&lt;/a&gt;. In this post, we extend our automatic differentiation system to support higher order derivatives.&lt;/p&gt;

&lt;p&gt;Like the previous post, some knowledge of calculus is required and Racket-y stuff will be explained as we go.&lt;/p&gt;&lt;a href="https://quasarbright.github.io/blog/2023/07/extending-automatic-differentiation-to-higher-order-derivatives.html?utm_source=projects&amp;amp;utm_medium=RSS"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</description></item>
  <item>
   <title>Understanding and Implementing Automatic Differentiation</title>
   <link>https://quasarbright.github.io/blog/2022/12/understanding-and-implementing-automatic-differentiation.html?utm_source=projects&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-quasarbright-github-io:-blog-2022-12-understanding-and-implementing-automatic-differentiation-html</guid>
   <pubDate>Sun, 04 Dec 2022 16:17:10 UT</pubDate>
   <author>Mike Delmonaco</author>
   <description>
&lt;p&gt;\[
\DeclareMathOperator{\expt}{expt}
\DeclareMathOperator{\mul}{mul}
\DeclareMathOperator{\add}{add}
\DeclareMathOperator{\derivative}{derivative}
\]&lt;/p&gt;

&lt;p&gt;Automatic differentiation is a technique that allows programs to compute the derivatives of functions. It is vital
for deep learning and useful for optimization in general.
For me, it&amp;rsquo;s always been dark magic, but I recently thought of a nice way to implement it and made a little library. This
blog post takes you along the journey of discovering that implementation. Specifically, we will be implementing forward mode
automatic differentiation for scalar numbers.&lt;/p&gt;

&lt;p&gt;This post requires some knowledge of differential calculus. You&amp;rsquo;ll need to know basic derivative rules, the chain rule,
and it&amp;rsquo;d help to know partial derivatives. If you&amp;rsquo;ve taken an introductory calculus course, you should be fine.&lt;/p&gt;

&lt;p&gt;The code is in Racket. If you don&amp;rsquo;t know Racket, you should still be able to follow along. I&amp;rsquo;ll explain the Racket-y stuff.
Don&amp;rsquo;t let the parentheses scare you away!&lt;/p&gt;&lt;a href="https://quasarbright.github.io/blog/2022/12/understanding-and-implementing-automatic-differentiation.html?utm_source=projects&amp;amp;utm_medium=RSS"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</description></item></channel></rss>